<?

imports := ""
for k, v in ctx.imports.__Enum(2) {
	parts := StrSplit(k, '$')
	imports .= ", ['" parts[1] "', '" parts[2] "'], " v
}
imports := "Map(" SubStr(imports, 3) ")"

relocations := ""
for v in ctx.relocations
	relocations .= ", " v
relocations := "[" SubStr(relocations, 3) "]"

exports := ""
for k, v in ctx.exports.__Enum(2)
	exports .= ", " v.value
exports := "[" SubStr(exports, 3) "]"

base64 := ctx.base64
base64Wrapped := '""'
while StrLen(base64) {
	base64Wrapped .= '`n. "' SubStr(base64, 1, 120 - 8) '"'
	base64 := SubStr(base64, (120 - 8) + 1)
}
?>
<?= ctx.name ?>() {
	static lib, code := Buffer(<?= ctx.codeSize ?>), codeB64 := <?= base64Wrapped ?>

	if (<?= ctx.bitness ?> != A_PtrSize * 8)
		throw Error("$Name does not support " (A_PtrSize * 8) " bit AHK, please run using <?= ctx.bitness ?> bit AHK")

	; MCL standalone loader https://github.com/G33kDude/MCLib.ahk
	; Copyright (c) 2023 G33kDude, CloakerSmoker (CC-BY-4.0)
	; https://creativecommons.org/licenses/by/4.0/

	if IsSet(lib)
		return lib

	if !DllCall("Crypt32\CryptStringToBinary", "Str", codeB64, "UInt", 0, "UInt", 1, <?
	?>"Ptr", buf := Buffer(<?= ctx.compressedSize ?>), "UInt*", buf.Size, "Ptr", 0, "Ptr", 0, "UInt")
		throw Error("Failed to convert MCL b64 to binary")

	if (r := DllCall("ntdll\RtlDecompressBuffer", "UShort", 0x102, "Ptr", code, "UInt", <?= ctx.codeSize ?>, <?
	?>"Ptr", buf, "UInt", buf.Size, "UInt*", &DecompressedSize := 0, "UInt"))
		throw Error("Error calling RtlDecompressBuffer",, Format("0x{:08x}", r))
	
<? if imports != "[]" { ?>
	for import, offset in <?= imports ?> {
		if !(hDll := DllCall("GetModuleHandle", "Str", import[1], "Ptr"))
			throw Error("Could not load dll " import[1] ": " OsError().Message)
		if !(pFunction := DllCall("GetProcAddress", "Ptr", hDll, "AStr", import[2], "Ptr"))
			throw Error("Could not find function " import[2] " from " import[1] ".dll: " OsError().Message)
		
		NumPut("Ptr", pFunction, code, offset)
	}
<? } ?>

<? if relocations != "[]" { ?>
	for k, offset in <?= relocations ?>
		NumPut("Ptr", NumGet(code, offset, "Ptr") + code.Ptr, code, offset)
<? } ?>

	if !DllCall("VirtualProtect", "Ptr", code, "Ptr", code.Size, "UInt", 0x40, "UInt*", &old := 0, "UInt")
		throw Error("Failed to mark MCL memory as executable")

	lib := {}

<?
for name, data in ctx.exports.__Enum(2) {
	if (data.type = "f") { ; function
		?>
	lib.<?= name ?> := ((this, p*) => DllCall(p*))
	static <?= name ?>(<?
		for v in StrSplit(data.types, "$") {
			if !(A_Index & 1) {
				if A_Index > 2 {
					?>, <?
				}
				?><?= v ?><?
				first := false
			}
		}
		?>) =>
		DllCall(this.code.Ptr + <?= data.value ?><? for v in StrSplit(data.types, "$") { ?>, <?= A_Index & 1 ? '"' v '"' : v ?><? } ?>)<?
	} else if (data.type = "g") { ; global
		?>
	static <?= name ?> {
		get => NumGet(this.code.Ptr + <?= data.value ?>, "<?= data.types ?>")
		set => NumPut("<?= data.types ?>", value, this.code.Ptr + <?= data.value ?>)
	}<?
	}
}
?>
}
